<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script type="module" src="./helpers.js"></script>
  <script type="module" src="../vaadin-grid.js"></script>
</head>

<body>
  <test-fixture id="default">
    <template>
      <vaadin-grid style="width: 50px; height: 400px;" size="100">
        <template class="row-details"><span>[[index]]</span>-details</template>
        <vaadin-grid-column>
          <template>[[index]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>
  <dom-module id="x-grid">
    <template>
      <vaadin-grid id="grid" style="width: 50px; height: 400px;">
        <template class="row-details"><span>[[index]]</span>-details</template>
        <vaadin-grid-column>
          <template>[[index]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
    <script type="module">
      import './helpers.js'; import '../vaadin-grid.js'; import { Polymer } from '../../@polymer/polymer/lib/legacy/polymer-fn.js';
      Polymer({ is: 'x-grid' });
    </script>
  </dom-module>
  <test-fixture id="with-scope">
    <template>
      <x-grid></x-grid>
    </template>
  </test-fixture>
  <test-fixture id="repeat">
    <template>
      <vaadin-grid style="width: 200px; height: 400px;" size="100">
        <template class="row-details">
          <div>
            <template is="dom-repeat" items="[[item.details]]">
              <div>foo</div>
            </template>
          </div>
        </template>
        <vaadin-grid-column>
          <template>[[index]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>
  <script type="module">
    import './helpers.js'; import '../vaadin-grid.js'; import { flush, dom } from '../../@polymer/polymer/lib/legacy/polymer.dom.js';
    import { Base } from '../../@polymer/polymer/polymer.js'; describe('row details', function() { var grid; var bodyRows;
    describe('simple', function() { function expandRow(index) { grid.expandItem(grid._cache[0][index]); } beforeEach(function(done)
    { // The before each block times out in CI with Firefox on Polymer 2 this.timeout(30000); grid = fixture('default');
    grid.dataProvider = infiniteDataProvider; flush(); bodyRows = getRows(grid.$.items); animationFrameFlush(function() {
    done(); }); }); function collapseRow(index) { grid.collapseItem(grid._cache[0][index]); } it('should expand a row', function(done)
    { expect(getRowCells(bodyRows[1])).to.have.length(1); expandRow(1); var cells = getRowCells(bodyRows[1]); expect(cells[1].hasAttribute('detailscell')).to.be.true;
    done(); }); it('should collapse a row', function() { expandRow(1); collapseRow(1); expect(getRowCells(bodyRows[1])).to.have.length(1);
    }); it('should stamp the details template', function() { expandRow(1); var cells = getRowCells(bodyRows[1]); expect(getCellContent(cells[1]).textContent.trim()).to.equal('1-details');
    }); it('should have correct bounds', function() { expandRow(1); var cells = getRowCells(bodyRows[1]); var bounds = cells[1].getBoundingClientRect();
    expect(bounds.top).to.equal(cells[0].getBoundingClientRect().bottom); expect(bounds.left).to.equal(cells[0].getBoundingClientRect().left);
    expect(bounds.right).to.equal(grid.$.items.getBoundingClientRect().right); expect(bounds.bottom).to.be.closeTo(bodyRows[2].getBoundingClientRect().top,
    1); expect(bounds.height).to.be.above(10); }); it('should remove the details cell', function() { expandRow(1); var row
    = bodyRows[1]; grid.$.scroller.scrollToIndex(100); grid._flushItemsDebouncer(); expect(getRowCells(row)).to.have.length(1);
    }); it('should add details to fixed cells cache', function() { expandRow(1); grid.$.scroller.flushDebouncer('cache-elements');
    bodyRows = getRows(grid.$.items); expect(grid.$.scroller._frozenCells).to.contain(getRowCells(bodyRows[1])[1]); }); it('should
    add details from fixed cells cache on scroll', function() { expandRow(1); grid.$.scroller.scrollToIndex(100); grid.$.scroller.flushDebouncer('cache-elements');
    // TODO: Saulis: scrolling directly from index 100 to 0 will // take 2-3s longer in this test for some reason. Gave up
    after trying to figure it out for 60mins. grid.$.scroller.scrollToIndex(10); grid.$.scroller.scrollToIndex(0); grid.$.scroller.flushDebouncer('cache-elements');
    bodyRows = getRows(grid.$.items); expect(grid.$.scroller._frozenCells).to.contain(getRowCells(bodyRows[1])[1]); }); it('should
    remove details from fixed cells cache', function() { expandRow(1); grid.$.scroller.flushDebouncer('cache-elements');
    collapseRow(1); grid.$.scroller.flushDebouncer('cache-elements'); bodyRows = getRows(grid.$.items); expect(grid.$.scroller._frozenCells).to.be.empty;
    }); it('should remove details from fixed cells cache on scroll', function() { expandRow(1); grid.$.scroller.scrollToIndex(100);
    grid.$.scroller.flushDebouncer('cache-elements'); expect(grid.$.scroller._frozenCells).to.be.empty; }); it('should remove
    unused nodes from the light DOM', function(done) { expandRow(1); var childCount = dom(grid).querySelectorAll('vaadin-grid-cell-content').length;
    collapseRow(1); Base.async(function() { expect(dom(grid).querySelectorAll('vaadin-grid-cell-content').length).to.equal(childCount
    - 1); done(); }, 1); }); }); describe('inside a parent scope', function() { beforeEach(function() { // The before each
    block times out in CI with Firefox on Polymer 2 this.timeout(30000); grid = fixture('with-scope').$.grid; grid.items
    = ['foo', 'bar', 'baz']; bodyRows = getRows(grid.$.scroller.$.items); flush(); }); it('should have the correct index
    on details template', function() { // expand item 0 grid.expandItem('foo'); // expand item 1 grid.expandItem('bar');
    var firstRowCells = getRowCells(bodyRows[0]); var secondRowCells = getRowCells(bodyRows[1]); expect(getCellContent(firstRowCells[1]).textContent.trim()).to.equal('0-details');
    expect(getCellContent(secondRowCells[1]).textContent.trim()).to.equal('1-details'); }); }); describe('repeat', function()
    { var items = []; for (var i = 0; i
    < 50; i++) { items.push({details: [1, 2, 3, 4]}); } beforeEach(function() { //
      The before each block times out in CI with Firefox on Polymer 2 this.timeout(30000); grid=f ixture( 'repeat'); }); it(
      'should have correct height', function(done) { grid.expandItem(items[0]); listenOnce(grid, 'items-assigned', function() { var row=g etRows(grid.$.items)[0];
      expect(row.offsetHeight).to.be.above(70); done(); }); grid.dataProvider=f unction(params, callback) { callback(items);
      flush(); grid.fire( 'items-assigned'); }; }); }); }); </script>
</body>

</html>